{
  "name": "8-puzzle",
  "tagline": "Lisp program for solving the 8-puzzle",
  "body": "# 8-puzzle\r\n\r\n#8-Puzzle Description\r\nIn the study of Artificial Intelligence, the 8-puzzle is a \r\nsimple sliding puzzle \"toy\" problem used to illustrate the \r\nconcepts of search space. To solve this puzzle, 8 tiles are \r\nrepositioned about a 3x3 grid in a sliding fashion in order \r\nto acheive a goal state. These puzzles are represented in \r\nrow-major form, with the tiles being represented as 1-8, with \r\nthe space being represented as a 0. A standard 8-puzzle game is \r\nsimulated below:\r\n\r\n    1 3 4       1 3 4       1 3 4       1 3         \r\n    8 6 2   ->  8   2   ->  8 2     ->  8 2 4   ->  \r\n    7   5       7 6 5       7 6 5       7 6 5       \r\n\r\n    1   3       1 2 3       \r\n    8 2 4   ->  8   4   <- (This is the goal state!)    \r\n    7 6 5       7 6 5       \r\n\r\n#Program Objective\r\nThe objective of this assignment is to use the Lisp programming \r\nlanguage to solve the 8-puzzle using Breadth-First Search (BFS), \r\nDepth First Iterated Deepening (DFID), and A*, a heuristics-based \r\nsearch method.\r\n\r\n#BFS Strategy\r\nBreadth-First Search is a standard algorithm for searching graph \r\nstructures. From a given start state, this algorithm searches \r\nneighboring nodes of the same level first, before exploring \r\nneighbors present in the next level.\r\n\r\n          (1)\r\n         / | \\\r\n       (2)(3)(4)\r\n       /   |  | \\\r\n     (5)  (6)(7)(8)\r\n      |\r\n     (9)\r\n     \r\n     \r\n#DFID Strategy\r\nDepth First Iterated Deepening is a state spaace search strategy \r\nin which there is a depth limit to the Depth-First Search (DFS) \r\nwith increasing depth limits until a goal state is reached. This \r\nallows for a version of depth-first search similar to BFS but with \r\nmuch smaller memory requirements. \r\n\r\n#A* Search Strategy\r\nThe A* search algorithm is a version of Dijkstra's algorithm that \r\nperforms better than exhaustive searches in certain situations due to \r\nits use of heuristics to guide search.\r\nAs the search algorithm is running, A* determines the next node to \r\nexpand by determining the estimate of the cost or weight to reach \r\nthe goal state. This is done by using the following equation:\r\n\r\n    f(n) = g(n) + h(n)\r\n\r\nWhere n is the node on the path, g(n) is the cost from the start \r\nnode to the given n, and h(n) is the heuristic value that estimates \r\nthe remaining cost from n to the goal state.\r\n\r\n#Heuristics\r\nHeuristics can be both admissible and inadmissible. Admissable \r\nheuristics never overestimate the cost to reach the goal, allowing \r\nadmissible heuristics to find the shortest path. This program features \r\nboth inadmissible and admissible heuristics, and the summary statistics \r\nprinted during the program's runtime will indicate whether an algorithm \r\nis using an inadmissible or admissible heuristic, as well as a brief \r\nsummary of the heuristic itself. BFS and DFID are exhaustive search \r\ntechniques, and as a result do not use heuristics at all.\r\n\r\n#Program Usage\r\nTo run our program, a user must provide the start position of the puzzle.\r\n\r\n\r\nThis can be specified in a puzzle file, within the Lisp interpreter by \r\npassing a list to the 8puzzle function call, or interactively by calling \r\nthe 8puzzle function without a start state list.\r\n\r\nThe puzzlefile contains an 8-puzzle start position, consisting of 9 digits \r\nseparated by white space, in row-major order. The digits 1-8 represent \r\nthe 8 tiles, and 0 represents the blank.\r\n\r\nAn example of a goal state is the following puzzle configuration:\r\n\r\n    1 2 3       \r\n    8 0 4 \r\n    7 6 5\r\n\r\nThis configuration will be represented in the CLISP program as the \r\nfollowing list:\r\n\r\n    ( 1 2 3 8 0 4 7 6 5 )\r\n    \r\n------------------------------------------------------------\r\n\r\n#Program Usage Example: Running Program From Command Line\r\n\r\neasy.puz file:\r\n\r\n    1 3 4 \r\n    8 6 2 \r\n    7 0 5\r\n\r\nCommand Line: \r\n\r\n    clisp 8puzzle.lsp puzzlefile\r\n\r\n------------------------------------------------------------\r\n\r\n#Program Usage Example: CLISP, passing start state as list\r\n\r\nInside CLISP:\r\n\r\n    ( load '8puzzle )\r\n    ( 8puzzle '( 1 3 4 8 6 2 7 0 5 ) )\r\n\r\n------------------------------------------------------------\r\n\r\n#Program Usage Example: CLISP without passing in start state\r\n\r\nInside CLISP:\r\n\r\n    ( load '8puzzle )\r\n    ( 8puzzle )\r\n    Please enter a puzzle:\r\n    >> 1 3 4 8 6 2 7 0 5\r\n\r\n------------------------------------------------------------\r\n\r\n\r\n#Solving Worst.puz\r\n\r\nOur inadmissable heuristic for A* solves the worst.puz with the following output:\r\n\r\n    A* graph search ( heuristic: Count Manhattan Distance of Incorrect Elements and \r\n    add Nilsson sequence score ( Inadmissible ) )\r\n    ---------------------------------------------------------\r\n    Solution found in 32 moves\r\n    29578 nodes generated (17010 distinct nodes), 10567 nodes expanded\r\n\r\n    5 6 7       5 6 7       5 6 7       5 6 7       \r\n    4   8   ->  4 8     ->  4 8 1   ->  4 8 1   ->  \r\n    3 2 1       3 2 1       3 2         3   2       \r\n\r\n    5 6 7       5 6 7       5 6         5   6       \r\n    4   1   ->  4 1     ->  4 1 7   ->  4 1 7   ->  \r\n    3 8 2       3 8 2       3 8 2       3 8 2       \r\n\r\n    5 1 6       5 1 6       5 1 6       5 1 6       \r\n    4   7   ->    4 7   ->  3 4 7   ->  3 4 7   ->  \r\n    3 8 2       3 8 2         8 2       8   2       \r\n\r\n    5 1 6       5 1 6       5 1 6       5 1 6       \r\n    3 4 7   ->  3 4     ->  3   4   ->    3 4   ->  \r\n    8 2         8 2 7       8 2 7       8 2 7       \r\n\r\n      1 6       1   6       1 3 6       1 3 6       \r\n    5 3 4   ->  5 3 4   ->  5   4   ->  5 2 4   ->  \r\n    8 2 7       8 2 7       8 2 7       8   7       \r\n\r\n    1 3 6       1 3 6       1 3         1   3       \r\n    5 2 4   ->  5 2     ->  5 2 6   ->  5 2 6   ->  \r\n    8 7         8 7 4       8 7 4       8 7 4       \r\n\r\n    1 2 3       1 2 3       1 2 3       1 2 3       \r\n    5   6   ->    5 6   ->  8 5 6   ->  8 5 6   ->  \r\n    8 7 4       8 7 4         7 4       7   4       \r\n\r\n    1 2 3       1 2 3       1 2 3       1 2 3       \r\n    8   6   ->  8 6     ->  8 6 4   ->  8 6 4   ->  \r\n    7 5 4       7 5 4       7 5         7   5       \r\n\r\n    1 2 3       \r\n    8   4       \r\n    7 6 5\r\n    \r\nDue to the fact that worst.puz is not solvable with our other algorithms,\r\nwe included this here to show that one of our algorithm was able to solve it.\r\n\r\n#Authors\r\nJ. Anthony Brackins, Scott Carda, Leif Torgersen\r\n\r\n#Course\r\nWritten Spring 2016 for CSC447/547 AI class.\r\n\r\n#Modifications\r\nFor Additional Credit, the program has been expanded beyond the \r\nstandard 8-puzzle to handle N-puzzles, where N may be:\r\n\r\n* 3<sup>2</sup> - 1 = 8 (standard 8-puzzle)\r\n* 4<sup>2</sup> - 1 = 15-puzzle\r\n* 5<sup>2</sup> - 1 = 24-puzzle\r\n* etc.\r\n\r\nThe program has been scaled up so that the program will be able to \r\ngenerate the goal state of any given puzzle and determine the puzzle \r\nsize based on the size of the list read in as the initial puzzle state,\r\nas long as the initial puzzle given to the program is in a valid \r\nN-puzzle format.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}